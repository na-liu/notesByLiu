# 遗传算法

常用术语：

个体 individual 染色体 chromosome
基因 gene：个体中的每一-位成为一个基因，如X= 0111
交叉 crossover/recombination/reproduction
变异 mutation	种群population
种群的规模 population size：种群中含有的个体数
适应度 fitness：评价个体优劣的指标
编码 encoding 	解码 decoding

###一、编码&解码、适应度

chromosome/individual包括多个gene位

- 编码决定了个体基因的排列形式，从而决定了**选择、交叉及变异**的方式
- 编码决定了搜索的**困难度与复杂性**
- 编码决定了问题的**求解精度**

####适应度函数：

- 取正值

- x（个体）越好，适应度值越大

- 确保Fit(x) >= 0：【以下两种方法可以去除f(x)中的负值，并且在求最大值时保持顺序，求最小值时反转顺序】

  最大值：Fit(x) = f(x) - f<sub>min </sub> 或者  Fit(x) = 1/(f(x) + M)

  最小值：Fit(x) = f<sub>max</sub> - f(x)

####二进制编码、解码   

maxf(x),  x∈[a, b] ,精度e = 10^-α。

编码位数为m可表示的范围是[0, 2<sup>m</sup>-1]

- 编码：2<sup>m-1</sup>-1 < (b - a) / e <= 2<sup>m</sup>-1

- 解码：将原二进制数转为十进制，x =  Σ bi * 2<sup>i</sup>(i = 0~m-1)；

  (x - 0) / (2<sup>m</sup>-1 - 0) = (y - a) / (b - a)，即 y = a + (b - a) * x / (2<sup>m</sup>-1)

##### 例题：函数f(x)=x^2, 其自变量x在区间[0，31] 取整数值，求该函数的最大值。【使用进化算法求解

step0：随机产生N个个体**构造种群**p(0)。【方法：由题意，需要5个二进制位，对每一位生成(0,1)之间的随机数k，若k∈[0,0.5)将gene位置0；否则将基因位置1】如，01101 11000 01000 10011四个个体	

step1：**适应度计算**，对于本题目原函数就是一个正函数，所以可以将其作为适应度函数来计算。计算结果是选择适应度最好的个体，即11000

##### 多参数二进制编码

解决方法：**对每一个参数**按照其取值范围进行**编码**，顺序连接起来既可作为一个个体。

如，f(x, y) = x^2 + y^2，$x\in$[0,63]，$y\in$[0,63]，x,y都取整数。

x,y 个需要8位二进制位，那么编码个体就以x,y前后顺序连接起来形成16位二进制位。

#### 整数编码

TSP问题，如1->4->3->6->5->2->7->1

- 近邻表示：code:（4，7，6，3，2，5，1）【第1~7的下一个地点序号】decode:同理
- 次序表示：code:(1,3,2,3,2,1,1)【一般选择一个参考序列，如(1,...,n)。编码的号码为每一个位在参考序列的次序，并且将每一位编完码从参考序列中删掉，再对下一位进行编码】decode:几乎一致，就是一个反过程，仍然要从参考序列中一个一个删除。

####二维编码

####![1569569067926](../../图片/1569569067926.png)

###二、交叉

- **单点交叉**

  具具体操作是:在个体基因串中随机设定一个交叉点，该点前或后的两个个体的基因互换，并生成两个新个体。

- **两点交叉**

  随机产生两个交叉点，交换两个父代个体的交叉点间的gene。

- **多点交叉**

  随机生成多个交叉点，交换两个父代个体的被划分之后的1，3，5....区域的gene。不过一般不采用多点，容易破坏个体的优良特性。

- **均匀交叉**

  随机产生一个**交叉模板**，和父代个体相同长度的01字符串。如果该位是1，两个父代个体对应位置gene交换，入股哦是0，就不交换。

- **部分匹配交叉**【整数编码】

  每一个基因位的数字不允许相同。选择两个交叉点，对中间部分进行交换，同时需要弥补其他位可能重复的麻烦，所以需要将中间部分一对一映射，对两边部分**恢复合法性**。

  **步骤：**选择切点X，Y；交换中间部分；确定映射关系；将未换部分按照映射关系恢复合法性。

  实现：可以直接用一个一维数组就可以确定两者的映射关系。

  ```wiki
  int map[gene_size];
  p1 = [1,2,3,4,5]
  p2 = [1,3,2,5,4]
  X = 1, Y = 4	// 交换[2,3,4]和[3,2,5]
  memset(map,0,sizeof(map))
  for(int i = X; i < Y; i++) {
  	map[p1[i]] = p2[i];
  	map[p2[i]] = p1[i];
  }
  for(int i = 0; i < X; i++){
  	if (map[i] != INF){
  		p1[i] = map[p1[i]];
  		p2[i] = map[p2[i]];
  	}
  }
  for(int i = Y; i < gene_size; i++){
  	if (map[i] != 0){
  		p1[i] = map[p1[i]];
  		p2[i] = map[p2[i]];
  	}
  }
  // 结果O1 = [1,3,2,5,4] O2 = [1,2,3,4,5]
  ```

  eg：

  p1 = [12,10,6,9,4, | 1,13,0,11,5,3,7, | 14,2,8]

  p2 = [14,12,10,8,4, | 11,6,13,5,2,1,0, | 9,3,7]

  根据中间部分建立的map如下：map[x] = y


| **x** | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   | 12   | 13   | 14   |
| :---- | :--- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| y     | 7    | 3    | 5    | 1    | F    | 2    | 13   | 0    | F    | F    | F    | 5    | F    | 0    | F    |

​	  由该映射顺序可以得到三个映射，6、13、0都映射成7，1<--->3，11、5映射为2

  	O1 = [12 10 **7** 9 4 [11,6,13,5,2,1,0] 14 5 8]

  	O2 = [14 12 10 8 4 [1,13,0,11,5,3,7]  9 **1** **0**]

  ```
  for (int i = 0; i < 15; i++){
  	if(i > 4 && i < 12) { // 交换中间gene位
          int tmp = p1[i];
          p1[i] = p2[i];
          p2[i] = tmp;
  	} else if (map[i] != INF) {	// 需要映射
          int t = p[i];
          while(true){
          if(t == map[map[t]]) {p[i] = map[t];break;}
          else t = map[t]
          }
  	} // 不需要映射
  }
  ```

- 顺序交叉

  步骤：选择切点X，Y；交换中间部分；将父代P1、P2重新排序：part3 + part1 +part2；然后从P1中去除P2的part2的数字，将新的part1和3归位，还是将前面的几位按顺序放到part3的位置，剩余的数字按顺序放到part1的位置，part2的位置用P2的part2代替即可。

  举例说明：

  P1 = [2 1 | 3 4 5 | 6 7]

  P2 = [4 3 | 1 2 5 | 7 6]

  重新排序：

  P1 =  [6 7 2 1 3 4 5]    --去除P2的part2数字-->  [6 7 3 4] ---归位，part2用P2填充--> [3 4 1 2 5 6 7]

  P2 =  [7 6 4 3 1 2 5]    --去除P1的part2数字-->  [7 6 1 2] ---归位，part2用P2填充--> [1 2 3 4 5 7 6]

  其实，我认为，这道题思想根本不需要交换part的位置再重新归位，直接将P1中的1 2 5去除，即[3 4 6 7]，将剩余的项按照part1和3的个数，按序分成两半分别放在part1和3处即可，即[3 4    part2    6 7]。

- **循环交叉**

  从父代1随机找一个基因点，从父代2中找到该点对应的点，再去父代1中找，......循环往复，直到形成一个环。然后交换这些基因位就可以生成两个子代了。

  如，P1 = 【1 2 3 4 5 6 7 8 9】P2 = 【5 4 6 9 2 3 7 8 1】

  随机选定1，得到的环为：1 5 2 4 9 1

  的两个子代是：126453789和543926781

- **二维交叉**

  空间的某一范围区域交叉

###三、变异

取定一个变异概率p<sub>m</sub>(一般≤0.05)，给DNA的每一个gene位生成一个随机数r∈[0,1]，如果r≤p<sub>m</sub>则改变gene位。

【针对整数编码】

- 对换变异：随机选两个基因位交换
- 移位变异：任选一位移到最前
- 插入变异：任选一位，任选一插入点，插入

【针对实数编码】

- 均匀变异：任选一位v<sub>k</sub>，从区间[a<sub>k</sub>,b<sub>k</sub>]中任选一位v<sub>k</sub>‘，替换之。
- 正态变异：同上，且v<sub>k</sub>’~N(v<sub>k</sub>,σ<sup>2</sup>)
- 非一致变异： 将变异算子与进化代数联系起来，使得在进化的**初期，变异的范围相对较大**，随着进化的推进， 变异的范围越来越小。  同上， 随机生成一个数v<sub>k</sub>’代替v<sub>k</sub>，其中v<sub>k</sub>’服从N(v<sub>k</sub>, σ2(t))正态分布，这里t是进化的代数，σ2(t)随着t的增大而趋于0  

###四、选择

- **轮盘赌选择**

  为群体中每个个体指定饼图中一个小块。块的大小与个体的适应度成比例，适应度愈高，它在饼图中对应的小块所占面积也愈大。为了选取一个个体，要做的就是旋转这个轮子，直到轮盘停止时，看指针停止在哪一块上，就选中与它对应的那个个体。

  问题：

  1. 适应度为负值？f(x) + C (C是正数)    OR   f(x) - fmin

  2. 适应度越小越好？fmax - f(x)  OR  1 / (f(x) + C)

  3. 个体差异小？f(x) - fmin

     ​	要求maxf(x)，就可以f(x) - fmin - $sigma$

     ​	要求minf(x)，就可以fmax - f(x)

     还可以幂尺度化，e<sup>0.5*f(x)</sup>

  4. 个体差异太大？

     也可以幂尺度化，e<sup>0.0005*f(x)</sup>

- **排序选择法**

  将N个个体的适应度值排序，并且给定N个概率值作为i每一个个体的选择概率。

  也就是说，选择概率只和编号有关，和适应度值无关。这就不存在f(x)差距太大或太小的问题了。

- **排挤选择法**

  给定排挤参数cf，从N中选出cf个个体，从cf个个体中丢弃与新个体最相似的个体。

- **两两竞争法选择**

  在N个个体中随机选择2个，选择fit值大的；重复这个过程，直到选够数了

- **锦标赛选择**

  在N个个体中随机选择S个，选择fit值大的；重复这个过程，直到选够数了.S一般2~4就可以

  <font color = red>优点</font>：对个体fit值的正负无要求，选择更优秀的概率增强

- **精英保留**

  直接将N个个体中E个优秀个体保留到下一代中。
  
  <font color = red>优点</font>：最好的解不会被破坏掉
  
  <font color = red>缺点</font>：局部最优解增加，导致未成熟收敛