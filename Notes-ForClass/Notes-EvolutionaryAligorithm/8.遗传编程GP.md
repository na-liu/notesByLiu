<font color = #00FFCC>自动程序设计</font>：通过遗传算法的思想，先随机产生一个有错误的解，再一步步改进是他可以正常工作。

遗传编程与GA的框架类似，个体是计算机程序，搜索空间是计算机程序空间，目标是求解问题的程序【一般的GA目标是某一个问题的解】。

适合交叉和变异的语言---LISP	

其表示方式为：先序表达式/s-表达式（simple），如：（x+y） 表示为 + x y 

可以用一颗语法树来表示，内部节点由函数构成，叶子节点由变量或常量构成。

程序空间S包含函数集F和端点集T.

<font color = #00FFCC>个体初始化：</font>

1. 建立根结点：从$F$中随机选一个函数<font color = #00FFBB>根结点一定是从F中选择的</font>
2. 为根节点取子结点，每一个子结点从$T\cup F$中选
3. 如果某个结点是$T$中的，那么该结点就是叶子节点
4. 循环往复，标记所有的结点

<font color = #ooffcc>🎈个体初始化方法：</font>

1. <font color = #cc00ff>完全法</font>：给定最大深度D，如果结点**深度小于D**时，就从$F$中选择；如果是D，就从$T$中选择
2. <font color = #cc00ff>生长法</font>：给定最大深度D，如果结点**深度小于D**时，就从$F\cup T$中选择；如果是D，就从$T$中选择
3. <font color = #cc00ff>混合法</font>：从第2至D的每一个深度，生成相同个数的树。对每一个深度，一半是完全法，一半是生长法。

<font color = #00FFCC>适应度：</font>建立样本集，给定自变量x和因变量y的取值，运行程序得到输出值z，然后计算$e = \sum^{s}_{i=1}|z_i-y_i|$，用e作为适应度值，显然e越小，个体越好。

<font color = #00FFCC>遗传算子：</font>

- <font color = #cc00ff>复制算子</font>：给定参数$p_r=0.1$，从种群中基于适应度比例选出个体，不加改变的放到下一代种群中。

- <font color = #cc00ff>交叉算子</font>：从父代语法树中随机找一个交叉点，交换两个子树。$p_c$是选择是否交叉的概率，$p_{cn}$是是否选择内结点作为交叉点的概率。一般都取0.9。

  通常还会设置一个最大允许深度$D_c$进行控制深度，一旦超过了最大深度，解决：

  	- 法一：用父代代替子代
  	- 法二：重新交叉操作
  	- 法三：选择交叉点时只选则不会让深度超过$D_c$的交叉点。

- <font color = #cc00ff>变异算子</font>：随机找一个点，删除该点的子树，再随机插入一个子树。

  也有两个参数，$p_m$是是否变异的概率。$p_{nm}$是选择内节点作为变异点的概率。

  最好是可以有较低的概率使个体进行变异，这是个体重新进入种群范围的唯一途径。

<font color = #00FFCC>Attention：</font>

population_size一般取500以上；

除了遗传算子，还可以设计其他的操作算子



